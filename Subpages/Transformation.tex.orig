\section{Fehler bei der Transformation} \label{Fehler bei der Transformation}

Das Umsetzen von Continuous Delivery ist nicht einfach so möglich. Es werden hier häufig zwei Fehler gemacht. Zum einen neigen Unternehmen dazu, Continuous Delivery als einen Endzustand anzusehen bzw. es als ein Ziel zu behandeln. Ein weiterer Fehler ist es, viel Zeit und Energie darauf zu verwenden, sich Gedanken über die zu verwendenden Produkte zu machen.\\ \\Es gibt viele Projekte, die gescheitert sind. Ohne genaue Beispiele und Gründe zu kennen, lässt sich sagen, dass sehr Umfangreiche Projekte bzw. Software-Releases ein hohes Risiko darstellen, dass etwas bei der Produktivsetzung schiefläuft. Oft lässt sich der Funktionsumfang nur schlecht manuell testen. Die Auswirkungen von Änderungen werden nicht früh genug beachtet oder das Zusammenspiel verschiedener Komponenten …\\ \\Dadurch, dass bei Continuous Delivery ein erheblicher Teil des gesamten Release-Prozesses automatisiert wird, fällt ein großer Teil der manuell auszuführenden Aufgaben weg. Das Risiko sinkt. Auch, da es immer einen Weg zurück zur alten Version gibt, also ein Rollback oder direkt ein Fix nachgeschoben werden kann. Durch den Rollforward kann ein Unternehmen sofort eine korrigierte Version ausrollen.\\ \\In Kapitel \ref{entwicklung} wurde gezeigt wie komplex die Etablierung von Continuous Delivery für Unternehmen ist. Bei diesen Prozess können Probleme auftreten, die in diesem Abschnitt diskutiert werden. Die Menge der Probleme wird in sechs Kategorien eingeteilt. Builddesign, Systemmodularisierung, Integration, Testphase, Release, Mensch und Organisationsstruktur, welche im Anschluss diskutiert werden.

\subsection{Builddesign} \label{builddesgin}
Bereits die Entscheidung, wie das Builddesign aufgebaut und konfiguriert wird, kann eine zukünftige Problemursache darstellen. Ein Grund hier für kann die Erstellung von komplexen und unflexiblen Buildskripten sein. Das Builddesign ist dadurch stark an das Zielsystem gekoppelt, sodass minimale Skritpänderung zu Buildfehlern führen können. Dies erfordert einer extensiven Pflege- und Wartungsbedarf, welches die Einführung einer DevOps-Kultur verlangsamt. Aber auch stellt die Modellierung des Systems eine Abhängigkeit für das Builddesign dar, da die Auflösung von Abhängigkeiten kritisch sein könnte, wie z. B. zyklische Abhängigkeiten.

\subsection{Systemmodularisierung}  \label{Systemmodularisierung}
Wie in Abschnitt \ref{builddesgin} erwähnt wurde stellt die Systemmodularisierung eine weitere Problemursache dar. Eine geeignete Systemmodellierung führt zu einer autonomen und unabhängigen Entwicklung. Eine ungeeignete Architektur stellt in erster Hinsicht kein Problem dar. Allerdings ihre Auswirkungen schon. Von einer ungeeigneten Architektur ist dann die Rede, wenn sie monolithisch gekoppelt sei. Eine ungeeignete Systemmodularisierung führt zu einem überhöhten Entwicklungsaufwand, Testbarkeit und Wartbarkeit. Dadurch nimmt die Fehleranfälligkeit des Systems und Code-Inkonsistenz zu, und die Software befindet sich in einem nicht aus-lieferbaren Zustand. Jedoch kann bei einer geeigneten Architektur diese Probleme auftreten, indem zu starke Systemmodellierung betrieben wird. Das führt zu einer Erhöhung der Komplexität, sodass neue Teammitglieder die Software schwer weiterentwickeln und pflegen können \cite{Laukkanen.2017}. 

\subsection{Integration} \label{Integration}
Die Integration umfasst die Probleme, die bei der Zusammenführung von Softwarekomponenten entstehen \cite{LianpingEtPaddy.2015}. Sobald diese Komponenten nicht wie vorgesehen zusammengeführt werden können, fangen die Probleme an. Nicht selten kommt es vor, dass Entwickler einmal täglich Quellcodeänderungen hochladen. Das hat die Folge, dass eine hohe Anzahl von Änderungen mit sich bringt und diese im Konflikt mit anderen Änderungen stehen. Im Fall eines Fehlers im Buildprozess kann der Fehler nicht sofort identifiziert werden und es entsteht eine Arbeitsblockade. Des Weiteren hat diese Vorgehensweise den Nachteil, dass überhöhter Netzwerklatenz erzeugt wird. Eine oft genutzte Methode ist hier das Erstellen von mehreren Abzweigungen des Hauptentwicklungsstrangs, um Integrationsprobleme zu vermeiden. Während die Entwicklung an dem Hauptentwicklungsstrang voranschreitet, divergieren Verzweigungen immer weiter vom ursprünglichen Strang, sodass die Vereinigung dieser beiden Stränge ein Problem wird. Die Lösung dieser Viereinigungsproblemen resultiert in mehr Aufwand, was zur einer reduzierten Produktivität führt \cite{Laukkanen.2017}. 

\subsection{Testphase}

Bei bestimmten Tests entstehen hier langwierige Probleme, wie zum Beispiel ''flaky tests''. Bei diesen Tests werden zufällige Resultate erzeugt, die nicht determinierbar sind und erschweren somit die Testphase, sodass Entwickler eher verwirrt werden anstatt Auskunft zu erhalten. 

\begin{quote}\glqq ...several of the automated activities do not yield a clear “pass or fail”result. Instead, they generate logs, which are then inspected in order to determine whether there were any problems—something only a small minority of project members actually do, or are even capable of doing. \grqq~\cite[S.65]{Laukkanen.2017}\end{quote}
%


\subsection{Mensch und Organisationsstruktur}
<<<<<<< HEAD
Eine letzte Problemursache ist der Mensch. Die Adaption von Continuous Delivery erwartet Agilität. Das setzt voraus, dass eine Akzeptanz für agiles Vorgehen vorhanden sein ist. Sowohl auf Management- als auch auf Mitarbeiterebene wird Motivation und Disziplin erfordert, da die Strukturen. Des Weiteren muss erwähnt werden, dass in Softwareteams mehr Druck herrscht, was die Motivation der Teammitglieder beeinflussen und somit für eine angespannte Arbeitsatmosphäre sorgen könnte, da die Software sich in einem ständig auslieferbaren Zustand befinden muss. Aus technischer Sicht verlangt Continuous Integration/Delivery tiefes technisches Wissen im Bereich Build-Management und sowohl die Programmierung und Erstellung von unterschiedlichen Skripten. 
=======
Eine letzte Problemursache ist der Mensch, welches aktuell die größte Herausforderung darstellt. Die Adaption von Continuous Delivery erwartet Agilität. Das setzt voraus, dass eine Akzeptanz für agiles Vorgehen vorhanden sein sollte. Sowohl auf Management- als auch Mitarbeiterebene wird Motivation und Disziplin erfordert. Des Weiteren muss erwähnt werden, dass in Softwareteams mehr Druck herrscht, was die Motivation der Teammitglieder beeinflussen und somit für eine angespannte Arbeitsatmosphäre sorgen könnte, da die Software sich in einem ständig auslieferbaren Zustand befinden muss. Aus technischer Sicht verlangt Continuous Integration/Delivery tiefes technisches Wissen im Bereich Build-Management und sowohl die Programmierung und Erstellung von unterschiedlichen Skripten. 
>>>>>>> a882e8c95024b8836ac5650f62b076d9f6a69b6b
