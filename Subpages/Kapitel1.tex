\section{Entwicklung zur DevOps-Kultur} \label{entwicklung}
Es ist denkbar, einen gewissen Teil von Continuous Delivery auch ohne DevOps einzuführen. Hierfür muss es nicht zwingend gemischte Teams geben. Im Grunde reicht eine Zusammenarbeit an der Continuous-Delivery-Pipeline. Continuous Delivery verfolgt unterschiedliche Ziele von denen einige trotz einer reduzierten Pipeline erreicht werden können, ohne, dass eine völlige Umorganisation notwendig ist. Letztendlich bringen diese Ansätze allerdings weniger Vorteile mit sich. Wenn Continuous Delivery vollständig umgesetzt werden soll, gelingt dies nur mit der Einführung von DevOps. DevOps einzuführen, bedeutet jedoch eine fundamentale Änderung der Organisation. Eine solche Änderung ist mit einem erheblichen Aufwand verbunden und kann vor allem in großen Konzernen schwer umsetzbar sein. In diesem Kapitel wird darauf eingegangen, welche Aspekte dabei zu berücksichtigen sind und welche Folgen diese Transformation für Unternehmen hat [1].

\subsection{Umsetzung von Continuous Delivery}
Continuous Delivery ist zwar lediglich eine technische Praktik, trotzdem hat diese Disziplin verschiedene Auswirkungen auf die Organisation. Continuous Delivery steht und fällt mit der Pipeline. Das Umsetzen einer einfachen Delivery-Pipeline kann bereits mit simplen mitteln erfolgen. Vor allem zu Beginn eines Projekts kann der Aufbau einer solchen Pipeline verfolgt werden. Beispielsweise kann ein Unternehmen hier vorab mit den Phasen Commit und Deploy beginnen, da diese schließlich existieren müssen. Es ist dann möglich, die Pipeline im weiteren Verlauf schrittweise weiterzuentwickeln, indem entsprechende Phasen (z. B. automatisierte Tests) hinzugefügt werden. Wird Continuous Delivery zum Start eines Projekts eingeführt, kann dies auch bei der Auswahl der Technologien und Architekturen berücksichtigt werden [1]. \\ \\
Oft setzt Continuous Delivery allerdings an eine bestehende Codebasis an. Die bisherige Architektur ist somit nicht für den Einsatz von Continuous Delivery konzipiert worden. Wie eben erwähnt, müssen Prozesse zur Auslieferung der Software bereits bestehen, wodurch in gewisser Weise auch immer eine Delivery-Pipeline vorhanden ist. Nur können diese Prozesse sehr komplex sein. Das Ziel von Continuous Delivery ist allerdings, einen konstanten Fluss von Features und Codeänderungen durch die Pipeline zu erreichen. Hierbei muss der Value Stream betrachtet werden. Dies bezeichnet den derzeitigen Ablauf bis zum Release der Software. Werden nun die einzelnen Stationen betrachtet, lassen sich Optimierungsmaßnahmen ableiten. Es können beispielsweise Engpässe ermittelt werden, um den Fluss zu optimieren, auch wenn die Pipeline noch nicht gänzlich automatisiert ist. Dieses Verfahren wird als Value Stream Mapping bezeichnet und stellt eine wertvolle Analysetechnik dar, um bereits bestehende Pipelines schrittweise zu verbessern. Obwohl Continuous Delivery lediglich eine Sammlung verschiedener Werkzeuge ist, reicht es bei der Umsetzung oft nicht, schlicht entsprechende Techniken und Tools zu verwenden. Solange die Prozesse innerhalb der Organisation nicht ablaufen, wie bei einer gut geölten Maschine, kann hier keine signifikante Steigerung der Effizienz erreicht werden [5]. Der Schlüssel, um entsprechende Prozesse gut zum Laufen zu bringen ist dabei DevOps. Da hierfür das Wissen aus beiden Abteilungen zusammenkommt, eignet sich dies ideal um Continuous Delivery umzusetzen [1].

\subsection{Umsetzung von DevOps}
Continuous Delivery ist hauptsächlich mit der DevOps-Bewegung verbunden [3], da DevOps eine wirkungsvolle Optimierungsmaßnahme darstellt. Dabei fokussiert sich dieser Ansatz auf die Liefergeschwindigkeit, das kontinuierliche Testen in Produktionsähnlichen Umgebungen, kontinuierliche Rückmeldung und schnelle Reaktionsfähigkeit sowie, wie der Name bereits andeutet, das Auflösen der Teamgrenzen [5]. Immerhin sollen die Entwicklung und der Betrieb als eine Einheit agieren und Teams anhand von Komponente oder fachlichen Zuständigkeiten aufgeteilt werden, wodurch auch die vollständige Verantwortung für ein Modul bei dem entsprechenden Team liegt. Damit geht eine Änderung der Organisationsform einher, um eine Kultur und ein Umfeld zu schaffen, indem das Erstellen, Testen und Freigeben von Software schnell, häufig und zuverlässig erfolgen kann. Ein Großteil von DevOps befasst sich demnach mit der Prozessverbesserung durch eine radikale Automatisierung manueller Prozesse [7]. \\ \\
Viele Unternehmen sind bereits dabei, DevOps erfolgreich umzusetzen. Allerdings bleiben nach wie vor kritische Barrieren bei der Entwicklung, wie sie im folgenden Kapitel näher beschrieben werden. Dabei ist vermutlich die größte Hürde die Angst vor Veränderungen (siehe vorherige Abneigung gegenüber Clouds) [3]. Um diese Philosophie anzuwenden gibt es verschiedene Möglichkeiten, allerdings muss einem klar sein, was DevOps für das Unternehmen bedeutet. Zwei der größten Hindernisse, diese Disziplin erfolgreich umzusetzen, sind die Unternehmensarchitektur sowie Unternehmenskultur, die davon beeinflusst werden.

\subsection{Kultur}
Die Unternehmenskultur ist von der Transformation betroffen. Obwohl diese nicht greifbar und nur schwer zu ändern ist, ist es wichtig, eine Kultur zu schaffen, in welcher alle Menschen der Organisation bei der Verfolgung gemeinsamer Ziele zusammenarbeiten. Bei DevOps wird stets die primäre Bedeutung der Kultur hervorgehoben. Ein besonderer Fokus liegt dabei auf einer effektiven Zusammenarbeit der Entwickler und IT-Betriebsteams. Durch diese Kollaboration, welche die Unabhängigkeit und Selbständigkeit der Teams fördert, bedarf es einer zentralen Kontrolle nur noch um bestimmte Rahmenbedingungen zu etablieren und zu kontrollieren.\\ \\    
Ein Extrembeispiel bezüglich der im Unternehmen verfolgter Kultur ist wohl Netflix mit seiner Simian Army. Dabei werden regelmäßig zufällige Instanzen ihrer Architektur zerstört, um (kontrollierte) Unfälle zu simulieren. Somit wird das unabhängige Funktionieren der Komponenten sichergestellt. Leistungsstarke Unternehmen warten also nicht darauf, dass Ausfälle passieren, um daraus zu lernen und sich zu verbessern. Durch dieses radikale Vorgehen bzw. diese Architektur des Systems lassen sich sehr schnell Optimierungen ableiten [3].

\subsection{Architektur}
Continuous Delivery sowie DevOps und die somit weitgehend autonomne Teams bedeuten auch für die Architektur der Lösungen eine Herausforderung. Zum einen erfordert es ein gewisses Maß an Abstimmung zwischen den Teams, um gemeinsam die Architektur des Systems zu entwickeln. Das Festlegen der Architektonik durch eine zentrale Instanz stellt schließlich einen Widerspruch zu den eigenverantwortlichen Teams dar. Die Abstimmung erfolgt dabei über entsprechend definierte und moderierte Meetings, an denen auch zentrale Architekten teilnehmen können um relevante Themen aus den Plänen abzuleiten [1]. Zum anderen muss die Delivery-Pipeline des Systems auch entsprechend aufgebaut bzw. angepasst werden. Wird an einer Stelle des Systems eine Änderung durchgeführt, muss nicht die ganze Pipeline durchlaufen werden. Das würde zum Testen des gesamten Systems führen. Zwar kann dies durchaus sinnvoll sein, da Fehler in einer Komponente erst durch ein Fehlverhalten einer anderen Komponente auftreten können (Seiteneffekte), trotzdem wäre die Folge ein unnötig großer Aufwand und ein verzögertes Feedback. Durch Continuous Delivery ergibt sich demnach eine andere technische Umsetzung der Komponenten, denn jede Komponente sollte als eigene Einheit betrachtet und implementiert werden. Somit lassen diese sich unabhängig voneinander als Teil des Gesamtsystems deployen und durchlaufen jeweils eine eigene Pipeline. Das schnelle Feedback und die angestrebte Risikominimierung wird hierdurch erreicht. Schleicht sich ein Fehler ein, kann er leichter identifiziert werden, da die Deployment-Einheiten wesentlich kleiner sind. Auch die Kommunikation zwischen den Komponenten ist betroffen. Wird davon ausgegangen, dass jede Komponente als eigener Service implementiert wird, der als eigener Prozess auf dem Server läuft, muss die Kommunikation angepasst werden. Potenzielle Lösungen bieten REST oder entsprechende Message Oriented Middleware. Möglichst kleine, lose gekoppelte und gut gekapselte Module sind somit für Continuous Delivery sinnvoll (im Rahmen der objektorientierten Programmierung werden hier die Prinzipien des SOLID-Designs verfolgt). Die daraus resultierenden verteilten Systeme machen das Design entsprechender Schnittstellen zu einem wichtigen Faktor [1] \\ \\
Durch verschiedene Anpassungen der Architektur und den bisher erwähnten Anforderungen an die Organisation ergibt sich ein umfangreiches Zusammenwirken von Continuous Delivery und dem Softwarearchitekturansatz von Microservices. Microservices genügen den Anforderungen an einer Architektur für ein Continuous Delivery-System und setzen auch andere Aspekte (Technologiefreiheit, unabhängige Einheiten etc.) um [1]. Diese architektonischen Eigenschaften wurden hier sogar explizit priorisiert [3]. Somit ist die Einführung von Continuous Delivery im Grunde eine Einführung von Microservices. Bei der Umsetzung von Continuous Delivery muss demnach die Architektur der Software (gegebenenfalls) an einigen Stellen angepasst werden. Lediglich die Prozesse anzupassen bzw. zu ändern, reicht nicht aus [1].

\subsection{Technolgie}
Wie bereits erwähnt, ist die Technologiefreiheit ein Aspekt dieses Ansatzes. Da die Teams weitgehend autonom handeln können, übernehmen sie die vollständige Zuständigkeit bei der Auswahl ihrer Implementierungstechnologien. Frameworks, Programmiersprachen oder Application Server werden eigenverantwortlich ausgewählt. Diese Entscheidungen haben an einigen Stellen starken Einfluss auf die Pipeline. Programmiersprachen beeinflussen beispielsweise die Geschwindigkeit der Compiler, wodurch die benötigte Zeit beim Durchlaufen der Pipeline davon beeinflusst wird. Technologieentscheidungen haben demnach einen direkten Einfluss auf die Continuous-Delivery-Pipeline [1].\\ \\
Treten mit den ausgewählten Technologien Probleme auf, muss sich auch nur dieses Team mit der Behebung möglicher Fehler auseinandersetzen. Andere Teams bleiben davon unbeeinflusst. So lässt sich eine Vielzahl von Technologien im Unternehmen nutzen, während eine klassische Organisation diese möglichst einschränken und kontrollieren möchte. So sollen beispielsweise potentielle Risiken beim Interagieren der Komponenten minimiert werden. Teilen sich Komponente und Projekte dieselbe Programmiersprache und Infrastruktur, kann jeder Entwickler mit der entsprechenden Technologie umgehen. Es kann jedes Projekt in gewisser Weise unterstützt werden. Auch der Betrieb kann sich so auf eine Technologie fokussieren und ist mit möglichen Problemen dieses Stacks vertraut. Bei DevOps hingegen steht die Freiheit, eigene Entscheidungen zu treffen im Vordergrund. Jedes Team wählt den eigenen Technologie-Stack, welcher sich für die jeweilige Aufgabe am besten eignet bzw. mit welchem es am produktivsten arbeitet. Einen Standard-Technologie-Stack kann etabliert werden, indem auf Erfahrungen anderer Teams zurückgegriffen wird. Somit könnte es bereits einen Werkzeugkasten geben, welcher auch für andere Teams attraktiv ist. Es ist demnach möglich, dass trotz der völligen Freiheit bestimmte Technologien über verschiedene Teams und Projekte hinweg verwendet werden [1].

%\begin{figure}[h!]
%	\centering
%	\includegraphics[width=0.8\linewidth]{images/servicemodules.pdf}
%	\caption{Cloud-Servicemodelle} %Generelle
%	\label{fig:cnn_structure}
%\end{figure}